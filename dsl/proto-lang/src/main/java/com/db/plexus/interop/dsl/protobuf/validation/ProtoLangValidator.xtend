/**
 * Copyright 2017-2020 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * generated by Xtext 2.12.0
 */
package com.db.plexus.interop.dsl.protobuf.validation

import org.eclipse.xtext.validation.Check
import com.db.plexus.interop.dsl.protobuf.Package
import com.db.plexus.interop.dsl.protobuf.ProtobufPackage
import com.google.inject.Inject
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import com.db.plexus.interop.dsl.protobuf.NamedElement
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.naming.IQualifiedNameProvider
import com.db.plexus.interop.dsl.protobuf.Import
import com.db.plexus.interop.dsl.protobuf.ProtoLangImportResolver
import com.db.plexus.interop.dsl.protobuf.Field
import com.db.plexus.interop.dsl.protobuf.FieldLabel
import com.db.plexus.interop.dsl.protobuf.Proto
import com.db.plexus.interop.dsl.protobuf.ProtoSyntax
import com.db.plexus.interop.dsl.protobuf.ProtoLangConfig
import com.db.plexus.interop.dsl.protobuf.Method
import com.db.plexus.interop.dsl.protobuf.EnumValue
import com.db.plexus.interop.dsl.protobuf.Enum
import org.eclipse.xtext.EcoreUtil2

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ProtoLangValidator extends AbstractProtoLangValidator {
	
	private static final char DOT_CHAR = '.'
	private static final char UNDERSCORE_CHAR = '_'
	
	@Inject
	IContainer.Manager containermanager;

	@Inject
	ResourceDescriptionsProvider resourceDescriptionsProvider;
		
	@Inject
	IQualifiedNameProvider qualifiedNameProvider;
	
	@Inject
	ProtoLangImportResolver importResolver
	
	@Inject
	ProtoLangConfig protoLangConfig

	@Check
	def checkSinglePackageDeclaration(Package ele) {		
		if (ele.eContainer.eContents.filter(typeof(Package)).length > 1) {					
			error('Duplicated package declaration', ProtobufPackage.Literals.PACKAGE__IMPORTED_NAMESPACE)
		}
	}
	
	@Check
	def checkFullNameIsUnique(NamedElement element) {
		val name = qualifiedNameProvider.getFullyQualifiedName(element)
		val resourceDescriptions = resourceDescriptionsProvider.getResourceDescriptions(element.eResource());
		val resourceDescription = resourceDescriptions.getResourceDescription(element.eResource().getURI());
		for (IContainer c : containermanager.getVisibleContainers(resourceDescription, resourceDescriptions)) {
			for (IEObjectDescription od : c.getExportedObjectsByType(ProtobufPackage.Literals.NAMED_ELEMENT)) {
				if (name.equals(od.getQualifiedName()) && !od.EObjectOrProxy.equals(element)) {
					error("Duplicated qualified name: " + name + ". " + od.EClass.name + " with the same qualified name is already defined in " + od.EObjectOrProxy.eResource.URI, ProtobufPackage.Literals.NAMED_ELEMENT__NAME);
				}
			}
		}
	}
	
	@Check
	def checkEnumValueFullNameIsUnique(NamedElement element) {
		val name = qualifiedNameProvider.getFullyQualifiedName(element)
		val resourceDescriptions = resourceDescriptionsProvider.getResourceDescriptions(element.eResource());
		val resourceDescription = resourceDescriptions.getResourceDescription(element.eResource().getURI());
		for (IContainer c : containermanager.getVisibleContainers(resourceDescription, resourceDescriptions)) {
			for (IEObjectDescription od : c.getExportedObjectsByType(ProtobufPackage.Literals.ENUM_VALUE)) {
				if (name.equals(od.getQualifiedName()) && !od.EObjectOrProxy.equals(element)) {
					error("\"" + (od.EObjectOrProxy as EnumValue).name + "\" must be unique within \"" + od.qualifiedName.skipLast(1) + "\", not just within \"" + (od.EObjectOrProxy.eContainer as Enum).name + "\", because enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it.", ProtobufPackage.Literals.NAMED_ELEMENT__NAME);
				}
			}
		}
	}
	
	@Check
	def checkImport(Import ele) {
		val path = ele.importURI
		if (importResolver.resolveURI(ele.eResource.resourceSet, path) === null) {
			val resolveCandidates = importResolver.getResolveCandidates(path)
			error('Imported resource cannot be resolved: ' + path + '. The following candidates were checked: ' + resolveCandidates, ProtobufPackage.Literals.IMPORT__IMPORT_URI);			
		}				
	}
	
	@Check
	def checkFieldNumbers(Field field) {
		var fields = field.eContainer.eContents.filter(typeof(Field))
		for (otherField: fields) {
			if (otherField.number == field.number && !otherField.equals(field)) {
				error('The same number assigned to field "' + otherField.name + '"', ProtobufPackage.Literals.FIELD__NUMBER)
			}			
		}
	}
	
	@Check
	def checkFieldLabel(Field field) {
		var proto = EcoreUtil2.getContainerOfType(field, typeof(Proto))
		if (proto.syntax === ProtoSyntax.PROTO3) {
			if (field.label === FieldLabel.REQUIRED) {
				error('Required field label forbidden in plexus proto3', ProtobufPackage.Literals.FIELD__NUMBER)
			}
			if (field.label === FieldLabel.OPTIONAL) {
				error('Optional field label forbidden in plexus proto3', ProtobufPackage.Literals.FIELD__NUMBER)
			}
		}
	}

	@Check
	def checkProtoResourceName(Proto proto) {
		if (!protoLangConfig.strictMode) {
			return
		}
		val fileName = proto.eResource.URI.lastSegment
		var isValid = true		
		for (var i=0; isValid && i<fileName.length; i++) {			
			val c = fileName.charAt(i)
			isValid = (Character.isLowerCase(c) && Character.isLetter(c)) || Character.isDigit(c) || c == UNDERSCORE_CHAR || c == DOT_CHAR
		}
		if (!isValid) {			
			error('Resource name "' + fileName + '" is not valid. Only lower-case letters, digits, underscores and dots allowed.', proto, ProtobufPackage.Literals.PROTO__ELEMENTS)		
		}
	}
	
	@Check
	def checkFieldName(Field field) {
		if (!protoLangConfig.strictMode) {
			return
		}
		val name = field.name
		var isValid = name.length > 0 && Character.isLetter(name.charAt(0))
		for (var i=0; isValid && i<name.length; i++) {			
			val c = name.charAt(i)
			isValid = (Character.isLowerCase(c) && Character.isLetter(c)) || Character.isDigit(c) || c == UNDERSCORE_CHAR
		}
		if (!isValid) {
			val message = 'Field name "' + name + '" is not valid. Only lower-case letters, digits and underscores allowed. First symbol must be lower-cased letter.'
			error(message, field, ProtobufPackage.Literals.FIELD__NAME)		
		}
	}
	
	@Check
	def checkDefinitionName(NamedElement ele) {
		if (!protoLangConfig.strictMode) {
			return
		}
		if (ele instanceof EnumValue) {
			return		
		}
		val name = ele.name
		var isValid = name.length > 0 && Character.isLetter(name.charAt(0)) && Character.isUpperCase(name.charAt(0))
		for (var i=0; isValid && i<name.length; i++) {			
			val c = name.charAt(i)
			isValid = Character.isLetter(c) || Character.isDigit(c)
		}
		if (!isValid) {
			val message = 'Name of ' + ele.eClass.name + ' "' + name + '" is not valid. Only letters and digits allowed. First symbol must be upper-cased letter.'
			error(message, ele, ProtobufPackage.Literals.NAMED_ELEMENT__NAME)		
		}
	}
	
	@Check
	def checkEnumValueName(EnumValue ele) {
		if (!protoLangConfig.strictMode) {
			return
		}
		val name = ele.name
		var isValid = true
		for (var i=0; isValid && i<name.length; i++) {			
			val c = name.charAt(i)
			isValid = (Character.isLetter(c) && Character.isUpperCase(name.charAt(0))) || Character.isDigit(c) || c == UNDERSCORE_CHAR
		}
		if (!isValid) {
			val message = 'Name of ' + ele.eClass.name + ' "' + name + '" is not valid. Only letters, digits and underscores allowed. All letters must be upper-cased.'
			error(message, ele, ProtobufPackage.Literals.NAMED_ELEMENT__NAME)		
		}
	}
	
	@Check
	def checkMethodName(Method ele) {
		if (!protoLangConfig.strictMode) {
			return
		}
		val name = ele.name
		var isValid = name.length > 0 && Character.isLetter(name.charAt(0)) && Character.isUpperCase(name.charAt(0))
		for (var i=0; isValid && i<name.length; i++) {			
			val c = name.charAt(i)
			isValid = Character.isLetter(c) || Character.isDigit(c)
		}
		if (!isValid) {
			val message = 'Name of method "' + name + '" is not valid. Only letters and digits allowed. First symbol must be upper-cased letter.'
			error(message, ele, ProtobufPackage.Literals.METHOD__NAME)		
		}
	}
	
	@Check
	def checkPackageName(Package ^package) {
		if (!protoLangConfig.strictMode) {
			return
		}
		val name = ^package.importedNamespace
		var isValid = true		
		for (var i=0; isValid && i<name.length; i++) {			
			val c = name.charAt(i)
			isValid = (Character.isLowerCase(c) && Character.isLetter(c)) || Character.isDigit(c) || c == UNDERSCORE_CHAR || c == DOT_CHAR
		}
		if (!isValid) {
			val message = 'Package name "' + name + '" is not valid. Only lower-case letters, digits, underscores and dots allowed.'
			error(message, ^package, ProtobufPackage.Literals.PACKAGE__IMPORTED_NAMESPACE)		
		}
	}
	
	@Check
	def checkProtoResourceLocation(Proto proto) {
		if (!protoLangConfig.strictMode) {
			return
		}				
		val resource = proto.eResource
		val name = this.qualifiedNameProvider.getFullyQualifiedName(proto)		
		val segments = name.skipFirst(1).segments		
		val importPath = if (segments.length > 0) segments.join("/") + "/" + resource.URI.lastSegment else resource.URI.lastSegment
		val resolvedUri = this.importResolver.resolveURI(resource.resourceSet, importPath)	
		if (resolvedUri === null) {
			val candidates = this.importResolver.getResolveCandidates(importPath)
			val message = 'Resource folder do not correspond to its package name "' + name.skipFirst(1) + '". Valid locations for the resource: ' + candidates
			var package = proto.elements.filter(typeof(Package)).findFirst[x|true]					
			if (package === null) {
				error(message, proto, ProtobufPackage.Literals.PROTO__ELEMENTS)
			} else {
				error(message, package, ProtobufPackage.Literals.PACKAGE__IMPORTED_NAMESPACE)
			}
		}
	}		
}
